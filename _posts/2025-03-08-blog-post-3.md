---
title: 'Pseudo Numerical Solvers For Fast sampling'
date: 2025-03-08
excerpt: "Diffusion models have rapidly evolved as a leading paradigm for generative modeling, owing to their remarkable ability to produce high-quality and diverse samples. The initial milestone was set by Denoising Diffusion Probabilistic Models (DDPM), which formulated sampling as a gradual denoising Markov chain requiring hundreds to thousands of iterative steps, resulting in high computational cost. To address this, Denoising Diffusion Implicit Models (DDIM) introduced non-Markovian deterministic samplers that significantly reduced sampling steps while largely preserving generation quality. Subsequent work generalized diffusion sampling within a unified framework of stochastic differential equations (SDEs) and ordinary differential equations (ODEs), allowing sampling to be viewed as solving inverse SDE/ODEs and facilitating more efficient numerical solvers. Building on these insights, pseudo-ODE samplers and advanced solvers have further accelerated sampling without substantial quality degradation. More recently, novel approaches such as Consistency Models have emerged, which train neural networks to directly predict consistent samples across arbitrary noise levels, enabling single-step or few-step sampling that rivals multi-step diffusion methods in quality and speed. This progression reflects a clear trend towards improving sampling efficiency and flexibility while maintaining or enhancing sample fidelity, broadening the practical applicability of diffusion-based generative models."
permalink: /posts/2025/03/diffusion-model-3/
tags:
  - ODE
  - Diffusion Model
  - Numerical Computation
---

<details style="background:#f6f8fa; border:1px solid #e5e7eb; border-radius:10px; padding:.6rem .9rem; margin:1rem 0;">
  <summary style="margin:-.6rem -.9rem .4rem; padding:.6rem .9rem; border-bottom:1px solid #e5e7eb; cursor:pointer; font-weight:600;">
    <span style="font-size:1.25em;"><strong>üìö Table of Contents</strong></span>
  </summary>
  <ul>
	<li><a href="#section1">Langevin Dynamics Sampling</a>
		<ul>
		  <li><a href="#section1.1">From score matching to a sampler</a></li>
		  <li><a href="#section1.2">Annealed Langevin Dynamics</a></li>
		  <li><a href="#section1.3">Practical recipe</a></li>
		  <li><a href="#section1.4">Predictor‚ÄìCorrector view (bridge to modern samplers)</a></li>
		  <li><a href="#section1.5">Stability, complexity, and diagnostics</a></li>
		  <li><a href="#section1.6">Relation to DDPM SDE PF-ODE</a></li>
		  <li><a href="#section1.7">When to use Langevin-based sampling</a></li>
		  <li><a href="#section1.8">Minimal math summary</a></li>
		</ul>
	</li>
	<li><a href="#section2">Markov Chain-Based Sampling in DDPM</a></li>
	<li><a href="#section3">Non-Markovian Step-Skipping in DDIM</a>
		<ul>
		  <li><a href="#section3.1">Differences from DDPM</a></li>
		  <li><a href="#section3.2">Non-Markovian Forward Process</a></li>
		  <li><a href="#section3.3">Deterministic Sampling and Reverse Process</a></li>
		</ul>
	</li>
	<li><a href="#section4">PF-ODE Based Samplers: Pseudo Numerical Methods, DEIS, DPM-Solver, and Beyond</a>
		<ul>
			<li><a href="#section4.1">Numerical ODE Solver</a>
				<ul>
				  <li><a href="#section4.1.1">One-step vs Multi-step</a></li>
				  <li><a href="#section4.1.2">Implicit vs Explicit</a></li>
				</ul>
			</li>
			<li><a href="#section4.2">Local Truncation Error and Global Truncation Error</a>
				<ul>
				  <li><a href="#section4.2.1">Example with Euler Method</a></li>
				  <li><a href="#section4.2.2">Example with Henu Method</a></li>
				</ul>
			</li>
			<li><a href="#section4.3">Numerical ODE Solvers for Sampling</a></li>
			<li><a href="#section4.4">Fast Sampling for Diffusion Model</a>
				<ul>
				  <li><a href="#section4.4.1">DDIM</a></li>
				  <li><a href="#section4.4.2">PNDM</a></li>
				  <li><a href="#section4.4.3">DEIS</a></li>
				  <li><a href="#section4.4.4">DPM-Solver</a></li>
				  <li><a href="#section4.4.5">DPM-Solver++</a></li>
				  <li><a href="#section4.4.6">UniPC</a></li>
				</ul>
			</li>
		</ul>
	</li>
	<li><a href="#section5">Consistency Models</a></li>
  </ul>
</details>

Diffusion models have emerged as one of the most powerful generative modeling paradigms in recent years, demonstrating remarkable success in high-fidelity image, audio, and video synthesis.  A key factor behind their success lies not only in the model architecture or training objectives but also in the **sampling process**‚Äîthe method by which the model generates data from noise.  Over the past few years, the sampling landscape has undergone a rapid evolution, moving from slow, step-by-step Markov chains to advanced, high-order solvers and even single-step generation.

This article takes a deep dive into the **evolution of diffusion model sampling techniques**, tracing the progression from early score-based models with Langevin Dynamics, through discrete and non-Markov diffusion processes, to continuous-time SDE/ODE formulations, specialized numerical solvers, and cutting-edge methods such as consistency models, distillation, and flow matching.  Our goal is to provide both a **historical perspective** and a **unified theoretical framework** to help readers understand not only *how* these methods work but *why* they were developed.


# <a id="section1">1. Langevin Dynamics Sampling</a>

**Langevin dynamics (LD)** is a classical result originating from statistical physics and stochastic differential equations [^Parisi] [^Grenander]. In the field of machine learning, this equation was first widely cited in the context of energy-based models (EBMs) and Markov chain Monte Carlo (MCMC) [^Aapo]. In modern generative models, Song et al. [^Song_2019] first combined Langevin dynamics with score matching for generative sampling from high-dimensional data distributions.

LD treats sampling as **stochastic gradient ascent on log-density** with Gaussian noise injected to preserve the target distribution.  In the diffusion family, LD first appeared as the core sampler in **Noise-Conditional Score Networks (NCSN)**, where a network learns the **score** $\nabla_{\tilde{x}} \log p_{\sigma}(\tilde{x})$ of *noise-perturbed* data $\tilde{x}$ at multiple noise scales and uses **Annealed Langevin Dynamics (ALD)** to progressively refine samples from high to low noise.

---

## <a id="section1.1">1.1 From score matching to a sampler</a>

### Unadjusted Langevin dynamics sampling Algorithm (ULA)
 
Given a **true distribution** with density $p_{\text data}(x) \propto \exp(‚àíE(x))$, the continuous-time Langevin SDE is

$$
\mathrm{d}x_t = \nabla_x \log p_{\text data}(x_t)\,\mathrm{d}t + \sqrt{2}\,\mathrm{d}W_t\label{eq:1}
$$

Euler‚ÄìMaruyama discretization with stepsize $\eta > 0$ yields

$$
x_{k+1} = x_k + \eta\,\nabla_x \log p_{\text data}(x_k) + \sqrt{2\eta}\,z_k,\quad z_k \sim \mathcal{N}(0,I)\label{eq:2}
$$

Repeat this process for $T \to \infty$, when $\nabla_x \log p_{\text data}(x_k)$ is **Lipschitz** and $\eta$ is small enough, Langevin dynamics sampling guarantees to converge to $x_{T} \sim p_{\text data}(x)$. To calculate the score function, we build a neural network $s_{\theta}(x)$ to  The core idea is to minimize the Fisher divergence between the true data distribution and the model:

$$
\mathcal{L}(\theta) = \mathbb{E}_{x \sim p_{\text{data}}}\left[
\big\|\,s_{\theta}(x) - \nabla_x \log p_{data}(x)\,\big\|_2^2
\right].
$$

Since $\nabla_x \log p_{\text{data}}(x)$ is unknown, Hyv√§rinen proposed **Score Matching (SM)**, which showed that via **integration by parts** (under suitable boundary conditions), the objective can be rewritten in a form **only involving** the model‚Äôs score function:

$$
\begin{align}
\mathcal{L}_{\text{SM}}(\theta) & = \mathbb{E}_{p_{\text{data}}} \left[ \frac{1}{2} \| s_\theta(x) \|^2 + \nabla_x \cdot s_\theta(x) \right] \\[10pt]
& \approx \frac{1}{N}\sum_{i=1}^{N} \left[ \frac{1}{2} \| s_\theta(x_i) \|^2 + \nabla_x \cdot s_\theta(x_i) \right] 
\end{align}
$$

where $\nabla_x \cdot s_\theta(x) = {\text{trace}(\nabla_x s_\theta(x))}$ is the divergence of the score field. However, SM is not scalable especially for high-dimension data points, because the second term is the jacobin of score model, calculate he exact score of $p(x)$ is impossible, since we don't know the true data distribution $p(x)$. 

Hyv√§rinen proposed score matching 

**Score learning via Denoising Score Matching (DSM).**  
NCSN avoids learning the exact score of $p(x)$. Instead it learns scores of **Gaussian-smoothed** marginals:

- Let $p_\sigma(x) = (p * \mathcal{N}(0,\sigma^2 I))(x)$.
- Train $s_\theta(x,\sigma) \approx \nabla_x \log p_\sigma(x)$ by minimizing

$$
\mathbb{E}_{\sigma\sim \pi} \;\mathbb{E}_{x_0\sim p}\;\mathbb{E}_{\varepsilon\sim\mathcal{N}(0,I)}
\left[
\lambda(\sigma)\,\big\|\,s_\theta(x_0+\sigma \varepsilon,\,\sigma)\;+\;\tfrac{1}{\sigma^2}\varepsilon\big\|_2^2
\right].
$$

Here the target score of the perturbed sample \(x = x_0+\sigma \varepsilon\) is \(-\varepsilon/\sigma^2\).  
A common choice is \(\lambda(\sigma)=\sigma^2\) to balance gradients across noise levels.

---

## <a id="section1.2">Annealed Langevin Dynamics (ALD)</a>

Direct ULA on \(p(x)\) mixes slowly in high dimensions. NCSN introduces a **noise schedule**
\(\sigma_1 > \sigma_2 > \cdots > \sigma_L\) (geometric decay), and runs ULA at each scale using the *smoothed* score:

$$
x \leftarrow x + \alpha_i\, s_\theta(x, \sigma_i) + \sqrt{2\alpha_i}\,z,\quad
\alpha_i = \epsilon \sigma_i^2,\; z\sim\mathcal{N}(0,I).
$$

Key heuristics:
- Initialize \(x\sim \mathcal{N}(0, \sigma_1^2 I)\).
- Use \(K_i\) inner steps per level (often 1‚Äì10); larger \(K_i\) for smaller œÉ.
- Choose \(\epsilon \in [10^{-3}, 10^{-1}]\) depending on dataset and architecture.

**Why it works.**  
At large œÉ, \(p_\sigma\) is close to Gaussian ‚Üí easy to explore by LD.  
As œÉ decreases, \(p_\sigma\) sharpens toward \(p\). ALD is a **homotopy** from easy to hard distributions, carrying samples along the score field \(s_\theta(\cdot,\sigma)\).

---

## <a id="section1.3">Practical recipe (pseudocode)</a>

```text
Input: score network s_Œ∏(x, œÉ), schedule {œÉ1 > œÉ2 > ... > œÉL}, Œµ, {K_i}
x ‚Üê Normal(0, œÉ1^2 I)
for i in 1..L:                     # noise annealing loop
  Œ± ‚Üê Œµ ¬∑ œÉ_i^2
  for k in 1..K_i:                 # inner Langevin steps
    z ~ Normal(0, I)
    x ‚Üê x + Œ± ¬∑ s_Œ∏(x, œÉ_i) + sqrt(2Œ±) ¬∑ z
return x
```

Tips:

- SNR-aware steps: Œ± ‚àù œÉ¬≤ stabilizes step sizes across levels.

- Score norm clipping (e.g., ‚Äñs‚Äñ ‚â§ c/œÉ) can prevent explosions at small œÉ.

- EMA weights at inference often improve smoothness.

---

## <a id="section1.4">Predictor‚ÄìCorrector view (bridge to modern samplers)</a>

In the continuous **VE/VP SDE** framework, sampling commonly alternates:
- **Predictor**: one step of reverse-time SDE (e.g., Euler‚ÄìMaruyama).
- **Corrector**: a few **Langevin** steps at the current time/œÉ (i.e., ALD as an MCMC corrector).

Thus, LD survives as the **‚Äúcorrector‚Äù module** even when predictors become advanced ODE/SDE solvers. This provides robustness (improved likelihood under small discretization error) at the cost of extra steps.

---

## <a id="section1.5">Stability, complexity, and diagnostics</a>

- **Step size**: For ULA on L-smooth log-densities, Œ∑ ‚â≤ 1/L is typical; in ALD, the œÉ¬≤ scaling implicitly adapts Œ∑ to local curvature.
- **Mixing**: Required steps generally scale with **inverse noise power**; more inner steps at small œÉ mitigate bias.
- **Failure modes**:
  - *Divergence at low œÉ*: reduce Œµ, add score clipping, or increase \(K_i\).
  - *Washed-out samples*: too large œÉ_max or too few steps at high œÉ.
  - *Mode bias*: insufficient inner steps at mid œÉ where multimodality emerges.
- **Diagnostics**: Track per-level gradient norms ‚ÄñsŒ∏(x,œÉ)‚Äñ, acceptance rates if using MALA (optional), and FID over partially annealed samples to locate bottlenecks.

---

## <a id="section1.6">Relation to DDPM / SDE / PF-ODE</a>

- **DDPM vs. ALD**: DDPM constructs a *reverse* Markov chain targeting the data distribution; ALD performs *forward-time* MCMC in the score field of smoothed densities.  
- **SDE unification**: NCSN with ALD aligns with the **VE-SDE** family; ALD steps are the ‚Äúcorrector‚Äù in the **predictor‚Äìcorrector** sampler.  
- **PF-ODE bridge**: Replacing the SDE predictor with the **probability flow ODE** yields deterministic trajectories; ALD can still serve as a corrector to reduce drift bias.

---

## <a id="section1.7">When to use Langevin-based sampling</a>

- **Pros**: Simple, robust, improves sample likelihood as a corrector, easy to plug into any score model.  
- **Cons**: Many steps; pure ALD is slower than modern ODE solvers (DPM-Solver/DEIS).  
- **Best practice**: Use **few-step ALD correctors** with strong predictors (reverse-SDE or PF-ODE), or as a fallback to fix discretization artifacts at low noise.

---

## <a id="section1.8">Minimal math summary (at a glance)</a>

- Discrete LD update:
  $$
  x_{k+1} = x_k + \eta\,\nabla_x \log p(x_k) + \sqrt{2\eta}\,z_k.
  $$
- DSM target at noise œÉ:
  $$
  \nabla_x \log p_\sigma(x_0+\sigma\varepsilon) = -\varepsilon/\sigma^2 .
  $$
- ALD step at level i:
  $$
  x \leftarrow x + (\epsilon\sigma_i^2)\, s_\theta(x,\sigma_i) + \sqrt{2\epsilon\sigma_i^2}\,z.
  $$

---

**Takeaway.**  
NCSN‚Äôs annealed Langevin Dynamics is the historical and conceptual precursor of today‚Äôs predictor‚Äìcorrector samplers. Even as high-order PF-ODE solvers dominate for speed, a *small number of LD corrector steps* often remains the most reliable way to recover sharp details at the final noise levels.





---





# <a id="section2">Markov Chain-Based Sampling in DDPM</a>



As introduced in the [previous post](https://innovation-cat.github.io/posts/2025/01/diffusion-model-2/), the reverse denoising process in diffusion models reconstructs the data distribution by iteratively reversing the forward noise addition. Each step in this reverse process is modeled as a Gaussian distribution, where the mean $\mu_\theta(x_t, t)$ and variance $\Sigma_\theta(x_t, t)$ are parameterized to approximate the true posterior transitions.

The reason $ p_\theta(x_{t-1} \mid x_t) $ exhibits Gaussian distribution characteristics is that it is designed to approximate the true posterior $ q(x_{t-1} \mid x_t, x_0) $, which itself is a Gaussian distribution derived from the forward process. Specifically, the forward diffusion steps involve Gaussian noise additions, making the conditional posteriors Gaussian. To elaborate: The true posterior $ q(x_{t-1} \mid x_t, x_0) $ can be computed using Bayes' rule and the Markov property of the forward chain:

$$
q(x_{t-1} \mid x_t, x_0) = \frac{q(x_t \mid x_{t-1}) q(x_{t-1} \mid x_0)}{q(x_t \mid x_0)}
$$

where all terms are Gaussian:

- $ q(x_t \mid x_{t-1}) = \mathcal{N}(x_t; \sqrt{\alpha_t} x_{t-1}, \beta_t I) $
- $$ q(x_{t-1} \mid x_0) = \mathcal{N}(x_{t-1}; \sqrt{\bar{\alpha}_{t-1}} x_0, (1 - \bar{\alpha}_{t-1}) I) $$
- $ q(x_t \mid x_0) = \mathcal{N}(x_t; \sqrt{\bar{\alpha}_t} x_0, (1 - \bar{\alpha}_t) I) $


Combining these, the posterior $ q(x_{t-1} \mid x_t, x_0) $ is also Gaussian:


$$
q(x_{t-1} \mid x_t, x_0) = \mathcal{N}\left( x_{t-1}; \tilde{\mu}_t(x_t, x_0), \tilde{\beta}_t I \right)
$$

with mean:

$$
\tilde{\mu}_t(x_t, x_0) = \frac{\sqrt{\bar{\alpha}_{t-1}} \beta_t}{1 - \bar{\alpha}_t} x_0 + \frac{\sqrt{\alpha_t} (1 - \bar{\alpha}_{t-1})}{1 - \bar{\alpha}_t} x_t
$$

and variance:

$$
\tilde{\beta}_t = \frac{(1 - \bar{\alpha}_{t-1}) \beta_t}{1 - \bar{\alpha}_t}
$$

Since $ x_0 $ is unknown during sampling, the model can approximates this by predicting different targets ( $ x_0 $, noise, velocity or score), leading to the parameterized $ p_\theta(x_{t-1} \mid x_t) \approx q(x_{t-1} \mid x_t, x_0) $ (with $ x_0 $ replaced by a learned estimate).

Thus, the reverse transition $ p_\theta(x_{t-1} \mid x_t) $ is explicitly defined as:

$$
p_\theta(x_{t-1} \mid x_t) = \mathcal{N}(x_{t-1}; \mu_\theta(x_t, t), \Sigma_\theta(x_t, t))
$$

If we leverage $x_0$ as our learning target ($x_0$-prediction), substituting $ x_0 $ with the predicted $$\hat{x}_0=x_{0, \theta}(x_t, t)$$:

$$
\tilde{\mu}_t(x_t, x_0) = \frac{\sqrt{\bar{\alpha}_{t-1}} \beta_t}{1 - \bar{\alpha}_t} x_{0, \theta}(x_t, t) + \frac{\sqrt{\alpha_t} (1 - \bar{\alpha}_{t-1})}{1 - \bar{\alpha}_t} x_t
$$

Or, If we leverage $\epsilon$ as our learning target ($\epsilon$-prediction), substituting $ x_0 $ with the noise predicted $\epsilon_{\theta}(x_t, t)$:

$$
\mu_\theta(x_t, t) = \frac{1}{\sqrt{\alpha_t}} \left( x_t - \frac{\beta_t}{\sqrt{1 - \bar{\alpha}_t}} \epsilon_\theta(x_t, t) \right)
$$


For the variance, DDPM uses a fixed schedule:

$$
\Sigma_\theta(x_t, t) = \sigma_t^2 I, \quad \sigma_t^2 = \tilde{\beta}_t = \frac{1 - \bar{\alpha}_{t-1}}{1 - \bar{\alpha}_t} \beta_t
$$

which directly matches the posterior variance $\tilde{\beta}_t$, interpolating between the forward variance $\beta_t$ and a value that aligns with the mode of the reverse posterior for better stability. Alternatives include setting $\sigma_t^2 = \beta_t$, but the mode-matched $\tilde{\beta}_t$ empirically yields higher sample quality by reducing variance mismatch in the early steps.

This Gaussian approximation ensures that the reverse chain closely approximates the true data-generating process, allowing the model to generate samples by starting from pure noise and progressively refining them through these Gaussian transitions. The integration of noise prediction ties directly into the training objective, as detailed next.

# <a id="section3">Non-Markovian Step-Skipping in DDIM</a>

Building on DDPM's foundation, Denoising Diffusion Implicit Models (DDIM), proposed by Song et al. in 2021, introduce non-Markovian processes to accelerate sampling by skipping steps, reducing iterations from thousands to tens while preserving quality. Unlike DDPM's stochastic Markov chains, DDIMs employ deterministic mappings, enabling implicit generative modeling where the forward process is non-Markovian, allowing flexible trajectories and latent interpolations. This shift not only boosts speed but also unlocks applications like semantic image editing, marking a pivotal evolution in diffusion sampling.


## <a id="section3.1">Differences from DDPM</a>
DDPM assumes a Markovian forward process where each step depends only on the previous, leading to stochastic reverse sampling. DDIM generalizes this by constructing non-Markovian diffusions that maintain the same marginals $q(x_t \mid x_0)$ but alter dependencies, making the reverse process implicit and deterministic when noise variance $\sigma_t = 0$. This results in consistent samples from the same initial noise across different step counts, unlike DDPM's variability, and allows encoding observations into latents with low reconstruction error.

## <a id="section3.2">Non-Markovian Forward Process</a>

The forward process is defined as:

$$
q_\sigma(x_{1:T} \mid x_0) := q_\sigma(x_T \mid x_0) \prod_{t=2}^T q_\sigma(x_{t-1} \mid x_t, x_0)
$$

with marginals matching DDPM:

$$
q_\sigma(x_t \mid x_0) = \mathcal{N}(\sqrt{\alpha_t} x_0, (1 - \alpha_t) I)
$$

The conditional transition is:

$$
q_\sigma(x_{t-1} \mid x_t, x_0) = \mathcal{N}\left( \sqrt{\alpha_{t-1}} x_0 + \sqrt{1 - \alpha_{t-1} - \sigma_t^2} \cdot \frac{x_t - \sqrt{\alpha_t} x_0}{\sqrt{1 - \alpha_t}}, \sigma_t^2 I \right)
$$

where $\sigma_t$ controls stochasticity (e.g., $\sigma_t = 0$ for determinism). This non-Markovian setup ensures the training objective remains identical to DDPM's noise prediction loss.

## <a id="section3.3">Deterministic Sampling and Reverse Process</a>

For deterministic sampling ($\sigma_t = 0$):

$$
x_{t-1} = \sqrt{\alpha_{t-1}} \left( \frac{x_t - \sqrt{1 - \alpha_t} \epsilon_\theta(x_t, t)}{\sqrt{\alpha_t}} \right) + \sqrt{1 - \alpha_{t-1}} \cdot \epsilon_\theta(x_t, t)
$$

The reverse transitions are:

$$
p_\theta(x_{t-1} \mid x_t) = q_\sigma(x_{t-1} \mid x_t, \hat{x}_0)
$$

where $\hat{x}_0 = \frac{x_t - \sqrt{1 - \alpha_t} \epsilon_\theta(x_t, t)}{\sqrt{\alpha_t}}$ is the predicted clean data.

DDIM's non-Markovian flexibility bridges probabilistic and deterministic generation, reducing NFEs while enabling novel capabilities, but still requires multi-step iterations, motivating ODE-based refinements.


# <a id="section3">PF-ODE Based Samplers: Pseudo Numerical Methods, DEIS, DPM-Solver, and Beyond</a>






Diffusion models involves a forward diffusion process that gradually adds Gaussian noise to data samples until they become pure noise, and a reverse process that learns to denoise this noise back to generate new samples. 

Mathematically, the forward process can be modeled as a stochastic differential equation (SDE): 

$$dx = f(x, t) \, dt + g(t) \, dw$$ 

where $x$ is the state variable (e.g., an image), $t$ is the time step, $f(x, t)$ is the drift term, $g(t)$ is the diffusion coefficient, and $dw$ represents Wiener process. The reverse process, used for sampling, is another SDE that approximates the time-reversal of the forward SDE, incorporating a score function $\nabla_x \log p_t(x)$ (the gradient of the log-probability density), which is estimated by a neural network trained via score matching.

A crucial insight is that this reverse SDE has an equivalent deterministic representation through the probability flow ordinary differential equation (PF ODE): 

$$\frac{dx}{dt} = f(x, t) - \frac{1}{2} g(t)^2 \nabla_x \log p_t(x)$$

This equivalence stems from the fact that the PF ODE is derived to match the Fokker-Planck equation (which describes the evolution of probability densities) of the original SDE, ensuring that trajectories generated by solving the ODE backward (from $t = T$ at pure noise to $t = 0$ at clean data) produce the same marginal probability distributions as the stochastic SDE paths, but without injecting additional randomness. Thus, sampling reduces to numerically integrating this ODE, making the process deterministic and potentially more efficient, as it avoids the variance introduced by stochastic sampling while preserving the generative quality.

In this post, we first review the numerical methods for solving ODEs. Then, we analyze why we do not directly use ODE numerical solvers for sampling in diffusion models. Finally, we explore how to construct an efficient sampler based on the properties of PF-ODE for sampling.


## <a id="section4.1">Numerical ODE Solver</a>

Numerical methods convert a continuous‚Äêtime initial-value problem into a sequence of discrete algebraic updates that march the solution forward in small time steps.

Numerical ODE solvers work by discretizing the continuous time domain into a sequence of time points: $t_0, t_1, ..., t_{n-1}, t_n$, the interval between any two adjacent time steps is $h$, i,e,. $t_i=t_{i-1}+h$. Given an initial-value problem:

$$
\frac{dx}{dt}=f(t,x),\ \ \ \ x(t_0)=x_0
$$

the Fundamental Theorem of Calculus rewrites the update over one step $h$:

$$
x_{t_{i+1}}=x_{t_i}+h \int_{t_i}^{t_{i+1}}f(t,x)dt
$$

Because the exact integrand $f(t,x)$ is unknown (it involves the unknown path $x$), numerical schemes replace that integral with a tractable quadrature formula  built from sample slopes. The essential difference between different numerical methods lies in the different strategies they use to approximate this integral. 

### <a id="section4.1.1">One-step vs Multi-step</a>

This research dimension answers the question: **"How much historical information is needed to computer $x_{t_{n+1}}$?"**

#### 1. One-step Methods

A one-step method uses only the information from the single previous point $(t_n, x_{t_n})$ to compute $x_{t_{n+1}}$, it does not care about earlier points like $x_{t_{n-1}}$, $x_{t_{n-2}}$, etc. That is to say, The information for $x_{t_{n+1}}$ is determined entirely by $x_{t_n}$ and some estimates of the slope within the interval $[t_n, t_{n+1}]$, we formalize as general form $x_{t_{n+1}}=\Phi(t_n, x_{t_n}, h)$   

Some classic numerical one-step methods are listed as follows:

|    Methods     | Order   |  NFE | Sampling Points| Update (explicit form) |
| :--------:  | :-----:  | :----:  | :--------:  | :-----:  | :----:  |
| Euler | 1 |1| $t_n $ | $$x_{t_{n+1}} = x_{t_n} + h*f(t_n, x_{t_n})$$ |
|  Heun (RK2)  | 2 |2| $$t_n \\ t_n+h$$ |  $$k_1=f(t_n, x_{t_n}) \\ k_2=f(t_n+{h}, x_{t_n}+{h}*k_1)  \\  x_{t_{n+1}}=x_{t_n}+\frac{h}{2}*(k_1+k_2)$$ |
| RK3 | 3 |3 | $$t_n \\ t_n+\frac{h}{2} \\ t_n+h$$ | $$k_1=f(t_n, x_{t_n}) \\ k_2=f(t_n+\frac{h}{2}, x_{t_n}+\frac{h}{2}k_1) \\  k_3=f(t_n+h, x_{t_n}-hk_1+2hk_2)  \\  x_{t_{n+1}}=x_{t_n}+\frac{h}{6}(k_1+4k_2+k_3)$$ |
| RK4|4 |4|  $$t_n \\ (t_n+\frac{h}{2})(2\times) \\ t_n+h$$ | $$k_1=f(t_n, x_{t_n}) \\ k_2=f(t_n+\frac{h}{2}, x_{t_n}+\frac{h}{2}k_1) \\ k_3=f(t_n+\frac{h}{2}, x_{t_n}+\frac{h}{2}k_2) \\  k_4=f(t_n+h, x_{t_n}+hk_3)  \\  x_{t_{n+1}}=x_{t_n}+\frac{h}{6}(k_1+2k_2+2k_3+k_4)$$ |

Geometrically, The integral on the right equals the signed area enclosed by the curve $f(t,x)$, the 
$t$-axis, and the vertical lines $t=t_i$ and $t=t_{i+1}$. Higher order numerical methods guarantee a better asymptotic error bound when all other factors (step size, stability, constants, arithmetic) are favourable.

![Area Approximations of 8 Common Explicit ODE Methods](/images/posts/post_3/1.png)

However, in real problems those factors often dominate, so a lower-order method can outperform a higher-order one.

#### 2. Multi-step Methods

A multi-step method uses not only the information from the single previous point $(t_n, x_{t_n})$, but also from previous points, such as $(t_{n-1}, x_{t_{n-1}}), (t_{n-2}, x_{t_{n-2}})$, etc. we formalize as general form $x_{t_{n+1}}=\Phi(h, f_{n}, f_{n-1}, f_{n-2},...)$ , where $f_i=f(t_i, x_(t_{i}))$. 

Traditional multi-step methods including Adams family (Adams-Bashforth, Adams-Moulton), Backward Differentiation Formulas (BDF).

### <a id="section4.1.2">Implicit vs Explicit</a>

This research dimension aims to answer the question: "Is the formula for $x_{t_{n+1}}$ is a direct calculation or an equation to be solved?", that is to say, whether $x_{t_{n+1}}$ appears on both sides of the equation simultaneously.

#### Explicit

Explicit methods refers to the formula for $x_{t_{n+1}}$ is an explicit expression, where the unknown  $x_{t_{n+1}}$ appears only on the left-hand side. We can directly plug in known values on the right-hand side to compute $x_{t_{n+1}}$.

Typical examples including forward euler method, RK families, Adams-Bashforth families.


#### Implicit

Implicit methods refers to the formula for  $x_{t_{n+1}}$ is an equation, where the unknown $x_{t_{n+1}}$  appears on both sides of the equals sign. Typical examples including backward euler method, Adams-Moulton families.

--- 


## <a id="section4.2">Local Truncation Error and Global Truncation Error</a>

In numerical methods for solving ordinary differential equations (ODEs), errors arise because we approximate the continuous solution with discrete steps. Two key concepts are the Local Truncation Error (LTE) and the Global Truncation Error (GTE), which are the common indicators used to measure errors.

-	**Local Truncation Error (LTE):** This is the error introduced in a single step of the numerical method, assuming the solution at the previous step is exact. It measures how well the method approximates the true solution over one step, based on the Taylor series expansion of the exact solution. 
	
	Mathematically, if the exact solution at $t_n$ is $x(t_n)$, the LTE at step $n+1$ is:
	
	$$
	\tau_{n+1} = x(t_{n+1}) - x_{n+1}^{\text{approx}}
	$$
	
	where $x_{n+1}^{\text{approx}}$ is computed using the method with exact input $x(t_n)$. 

- **Global Truncation Error (GTE):** This is the total accumulated error at the end of the integration interval (e.g., from $t_0$ to $T$), considering that errors from previous steps propagate forward. It depends on the number of steps $N = (T - t_0)/h$, and for stable methods, GTE is typically $O(h^p)$ if LTE is $O(h^{p+1})$. The relationship is roughly GTE $\approx$ (number of steps) $\times$ LTE, but propagation can amplify or dampen it.

Below, we will use the Euler method and the Henu method as examples to demonstrate how to obtain its LTE and GTE.


---

### <a id="section4.2.1">Example with Euler Method</a>
The forward Euler method is a first-order method:

$$x_{n+1} = x_n + h f(t_n, x_n)$$

#### Deriving LTE
- Assume exact input: Start with $x_n = x(t_n)$.

- The method approximates: $x_{n+1}^{\text{approx}} = x(t_n) + h f(t_n, x(t_n))$.

- From Taylor: $x(t_n + h) = x(t_n) + hf(t_n, x(t_n)) + \frac{h^2}{2} x''(t_n) + O(h^3)$.

- Subtract: LTE $\tau_{n+1} = x(t_n + h) - x_{n+1}^{\text{approx}} = \frac{h^2}{2} x''(t_n) + O(h^3)$.

- Thus, **LTE = $O(h^2)$**. (The leading term is quadratic in $h$.)

This shows how to arrive: The Euler update matches the first two Taylor terms (constant + linear), so the error starts from the quadratic term.

#### Deriving GTE

- Let $e_n = x(t_n) - x_n$ be the global error at step $n$.

- The error recurrence: $e_{n+1} = e_n + h [f(t_n, x(t_n)) - f(t_n, x_n)] + \tau_{n+1}$.

- For Lipschitz-continuous $f$ (with constant $L$), $\|f(x(t_n)) - f(x_n)\| \leq L \|e_n\|$, so:
$$\|e_{n+1}\| \leq \|e_n\| (1 + h L) + \|\tau_{n+1}\|$$

- Since $\tau_{n+1} = O(h^2)$, over $N$ steps ($N \approx 1/h$), the accumulated error bounds to $\|e_N\| \leq C h$ for some constant $C$ (from summing the geometric series of propagated local errors).

- Thus, GTE = $O(h)$. (Errors accumulate linearly with $1/h$ steps, reducing the order by 1.)

Cause: Each local error adds up, and propagation (via $1 + hL$) amplifies like compound interest, but stability ensures it's bounded by $O(h)$.

### <a id="section4.2.2">Example with Heun Method</a>

The Heun method (a second-order Runge-Kutta) improves on Euler with a predictor-corrector:

$$k_1 = f(t_n, x_n), \quad k_2 = f(t_n + h, x_n + h k_1), \quad x_{n+1} = x_n + \frac{h}{2} (k_1 + k_2)$$

#### Deriving LTE

- Assume exact input: $x_n = x(t_n)$.

- Expand $k_1 = f(t_n, x(t_n)) = x'(t_n)$.

- Predictor: $x_n + h k_1 = x(t_n) + h x'(t_n)$.

-  $k_2 = f(t_n + h, x(t_n) + h x'(t_n))$. Taylor-expand $f$ in two variables:

   $$
   \begin{align}
   f(t_n + h, x(t_n) + h x'(t_n)) = & f(t_n, x(t_n)) + h \left( f_t + x'(t_n) f_x \right) \\[10pt] & + \frac{h^2}{2} \left( f_{tt} + 2 x' f_{tx} + (x')^2 f_{xx} \right) + O(h^3)
   \end{align}
   $$ 
   
   But since $x'' = \frac{\partial f}{\partial t} + x' \frac{\partial f}{\partial x}$, $k_2 = x' + h x'' + \frac{h^2}{2} x''' + O(h^3)$.

- Then, 
 $$
 \begin{align}
 x_{n+1}^{\text{approx}} & = x(t_n) + \frac{h}{2} (x' + x' + h x'' + \frac{h^2}{2} x''' + O(h^3)) \\[10pt] & = x(t_n) + h x' + \frac{h^2}{2} x'' + \frac{h^3}{4} x''' + O(h^4)
 \end{align}
 $$

- True: $x(t_n + h) = x(t_n) + h x' + \frac{h^2}{2} x'' + \frac{h^3}{6} x''' + O(h^4)$.

- Subtract: LTE $\tau_{n+1} = \left( \frac{h^3}{6} - \frac{h^3}{4} \right) x''' + O(h^4) = -\frac{h^3}{12} x''' + O(h^4)$.
Thus, LTE = $O(h^3)$. (Matches up to quadratic term, error from cubic.)

#### Deriving GTE

-  Similar recurrence: 

   $$
   \begin{align}
   e_{n+1} =\  & e_n + \frac{h}{2} [ (f(t_n, y(t_n)) - f(t_n, y_n))] \\[10pt] &+ \frac{h}{2}[(f(t_{n+1}, y(t_{n+1})) - f(t_{n+1}, y_n + h k_1)) ] + \tau_{n+1}
   \end{align}
   $$

- Using Lipschitz $L$, the perturbation terms are $O(e_n)$ and $O(h e_n + e_n)$, leading to $\|e_{n+1}\| \leq (1 + h L + O(h^2)) \|e_n\| + \|\tau_{n+1}\|$.

- With $\tau_{n+1} = O(h^3)$, over $N \approx 1/h$ steps, the bound sums to $\|e_N\| \leq C h^2$ (accumulated as $N \times O(h^3) = O(h^2)$).

- Thus, GTE = $O(h^2)$. (Higher local order leads to better global convergence.)

Cause: Fewer accumulations needed for the same accuracy, and the method's stability (A-stable for some cases) prevents excessive propagation.

In summary, LTE is per-step (higher order means smaller), while GTE is overall (reduced by 1 order due to accumulation). For Euler (order 1), halving $h$ halves GTE; for Heun (order 2), it quarters GTE‚Äîmaking higher-order methods more efficient for accuracy.


## <a id="section4.3">Numerical ODE Solvers for Sampling</a>

Although the PF ODE formulation enables deterministic sampling, directly applying standard numerical ODE solvers (e.g., explicit Runge-Kutta methods like RK4, Euler methods, or adaptive solvers like Dormand-Prince) is often suboptimal or problematic for diffusion models. These general-purpose solvers do not fully exploit the specific structure of diffusion ODEs, leading to inefficiencies and quality issues, particularly in high-dimensional spaces like image generation. Below, I list the key reasons, drawn from analyses of diffusion sampling challenges:

- Numerical Instability and Stiffness Issues: Diffusion PF ODEs are semi-linear and can be stiff, especially in high dimensions, causing standard explicit solvers to become unstable with large step sizes. This results in exploding gradients or divergence, requiring tiny steps that increase computational cost and negate speed advantages.

- High Discretization Errors in Few-Step Regimes: With fewer integration steps (e.g., 10‚Äì20 instead of 1000), traditional solvers accumulate significant truncation errors, causing the approximated trajectory to deviate from the true ODE path. This leads to degraded sample quality, such as artifacts or lower fidelity, as the solver fails to accurately track the probability flow.

- Mismatch with Model Training Objectives: Diffusion models are trained to optimize score-matching losses, not to minimize ODE integration errors. Pursuing better ODE solving can paradoxically worsen perceptual quality, as seen in consistency models where tighter approximations to the PF ODE reduce sample fidelity due to inconsistencies between training and inference.

- Inefficiency for Guided or Conditional Sampling: Standard solvers do not inherently handle constraints like classifier guidance or conditional generation efficiently, often requiring additional modifications that increase function evaluations (NFEs) or fail to maintain distribution matching.

- Lack of Exploitation of Semi-Linear Structure: Diffusion ODEs have a specific semi-linear form (linear drift plus nonlinear score term), which general solvers ignore, leading to suboptimal performance. Without tailored approximations, they require more NFEs for convergence, making them slower than specialized methods.

These problems motivate the development of specialized solvers that incorporate higher-order approximations, exploit the ODE's structure, and provide convergence guarantees for fast, high-quality sampling in low-NFE settings.



## <a id="section4.4">Fast Sampling for Diffusion Models</a>

### <a id="section4.4.1">DDIM</a>

### <a id="section4.4.2">PNDM</a>

### <a id="section4.4.3">DEIS</a>

### <a id="section4.4.4">DPM-Solvers</a>

### <a id="section4.4.5">DPM-Solver++</a>

### <a id="section4.4.6">UniPC</a>


# <a id="section5">Consistency Models</a>
---

# <a id="section6">References</a>

[^Parisi]: Parisi G. Correlation functions and computer simulations[J]. Nuclear Physics B, 1981, 180(3): 378-384.

[^Grenander]: Grenander U, Miller M I. Representations of knowledge in complex systems[J]. Journal of the Royal Statistical Society: Series B (Methodological), 1994, 56(4): 549-581.

[^Aapo]: Aapo Hyv√§rinen, ‚ÄúEstimation of non-normalized statistical models by score matching‚Äù, JMLR, 2005.

[^Song_2019]: Yang Song and Stefano Ermon. "Generative Modeling by Estimating Gradients of the Data Distribution". NeurIPS 2019.


